import random

import spacy
from IPython.core.display import display
from ipywidgets import widgets
from spacy.matcher import PhraseMatcher
from sqlalchemy import or_

from db.ORMs import Document
from gui.PreviousNextWidgets import PreviousNextHTML
from gui.Workflow import Step, logConsole


class ReviewRBInit(PreviousNextHTML):
    """Start review samples with rule-based method in the backend.
    This is more efficient and practical when reviewed data are relatively small at the beginning."""

    description = "<h4>Review samples: </h4><p>These pre-annotations are generated by the keywords you put in. " \
                  "They will be used to train ML model in the backend.</p>"

    def __init__(self, description='', name=str(Step.global_id + 1)):
        self.nlp = None
        self.matcher = None
        self.sample_size_input = None
        self.percent_slider = None
        self.samples = {"contain": [], "notcontain": []}
        self.box = None
        self.data = None
        super().__init__(description=description, name=name)
        pass

    def start(self):
        self.init_real_time()
        self.updateBox()
        display(self.box)
        pass

    def updateBox(self):
        total_contain = len(self.samples['contain'])
        total_not_contain = len(self.samples['notcontain'])
        desc = widgets.HTML(value='<h3>Start sampling for reviewing</h3>'
                                  '<p>The whole corpus has %s samples that contain at least one of the keywords, '
                                  'and %s don\'t contain.</p>' % (total_contain, total_not_contain))
        recommended_samples = int(total_contain / 2 + total_not_contain / 4)
        min_samples = 0
        if recommended_samples > 400:
            recommended_samples = 400
        self.sample_size_input = widgets.BoundedIntText(value=recommended_samples, min=min_samples,
                                                        max=total_contain+total_not_contain, step=5,
                                                        description='Total samples you want to sample:')
        desc2 = widgets.HTML(value='<h4>Percentage to Filter: </h4><p>Choose how many percent of the samples '
                                   'you want to contain the filter keywords. The rest percentage will be sampled '
                                   'randomly from the samples that do not have any filter keywords.</p>')
        self.percent_slider = widgets.IntSlider(
            value=60,
            min=0,
            max=100,
            step=5,
            description='',
            disabled=False,
            continuous_update=False,
            orientation='horizontal',
            readout=True,
            readout_format='d'
        )
        self.box = widgets.VBox([desc, self.sample_size_input] + self.addSeparator(top='10px') + [desc2,
                                                                                                  self.percent_slider] + self.addSeparator(
            top='10px') + [self.addPreviousNext()])
        pass

    def init_real_time(self):
        self.workflow.final_filters = {**self.workflow.filters, **self.workflow.umls_extended,
                                       **self.workflow.we_extended}
        self.initSpacyNER()
        self.queryDocs()
        pass

    def initSpacyNER(self):
        self.nlp = spacy.blank('en')
        type_phrases = dict()
        for type_name, phrases in self.workflow.final_filters.items():
            type_phrases[type_name] = ([self.nlp(phrase) for phrase in phrases])
            self.matcher = PhraseMatcher(self.nlp.vocab)
        for type_name, phrases in type_phrases.items():
            self.matcher.add(type_name, None, *phrases)
        pass

    def queryDocs(self):
        self.samples = {"contain": [], "notcontain": []}
        with self.workflow.dao.create_session() as session:
            doc_iter = session.query(Document).filter(Document.DATASET_ID == 'origin_doc')
            for doc in doc_iter:
                if len(self.matcher(self.nlp(doc.TEXT))) > 0:
                    self.samples['contain'].append(doc.DOC_ID)
                else:
                    self.samples['notcontain'].append(doc.DOC_ID)
                pass


        pass

    def complete(self):
        self.getSampledDocs()
        super().complete()
        pass

    def getSampledDocs(self):
        self.workflow.sample_size = self.sample_size_input.value
        self.workflow.filter_percent = 0.01 * self.percent_slider.value
        random.shuffle(self.samples['contain'])
        random.shuffle(self.samples['notcontain'])
        contain_size = int(self.workflow.sample_size * self.workflow.filter_percent)
        notcontain_size = self.workflow.sample_size - contain_size
        if contain_size > len(self.samples['contain']):
            contain_size = len(self.samples['contain'])
            notcontain_size = self.workflow.sample_size - contain_size
        if notcontain_size > len(self.samples['notcontain']):
            notcontain_size = len(self.samples['notcontain'])
        self.workflow.sample_size = contain_size + notcontain_size
        self.workflow.filter_percent = 100.0 * contain_size / self.workflow.sample_size

        contain_docids = self.samples['contain'][:contain_size]
        notcontain_docids = self.samples['notcontain'][:notcontain_size]
        self.workflow.samples = {'docs': [], 'if_contains': {}}

        with self.workflow.dao.create_session() as session:
            doc_iter = session.query(Document).filter(Document.DATASET_ID == 'origin_doc').filter(
                or_(Document.DOC_ID.in_(contain_docids), Document.DOC_ID.in_(notcontain_docids)))
            for doc in doc_iter:
                if doc.DOC_ID in contain_docids:
                    self.workflow.samples['docs'].append(
                        Document(doc.DOC_ID, doc.DATASET_ID, doc.BUNCH_ID, doc.DOC_NAME, doc.TEXT, doc.DATE,
                                 doc.REF_DATE, doc.META_DATA))
                    self.workflow.samples['if_contains'][doc.DOC_ID] = 'contain'
                else:
                    self.workflow.samples['docs'].append(
                        Document(doc.DOC_ID, doc.DATASET_ID, doc.BUNCH_ID, doc.DOC_NAME, doc.TEXT, doc.DATE,
                                 doc.REF_DATE, doc.META_DATA))
                    self.workflow.samples['if_contains'][doc.DOC_ID] = 'notcontain'
        self.data = self.workflow.samples
        pass
